Java NIO
=======================
- [用户空间与内核空看](#用户空间vs内核空间)
- [NIO简介](#NIO介绍)
  - [I/O缓冲区](#I/O缓冲区)
    - [概念](#概念)
    - [文件读写基本流程](#文件读写基本流程)
- [零拷贝](#零拷贝)
- [mmap是什么](#mmap是什么)  

# 用户空间vs内核空间
从字面意思理解，就是：用户空间运行普通的应用程序；内核空间运行OS内核模块。

通常，OS会提供一些系统调用函数给应用程序，便于应用程序操作系统资源。比如：应用程序需要写数据到磁盘上，OS就会提供相应的Read和Write函数。

把“应用程序调用系统的函数”的操作称为“系统调用”。如果发生了“系统调用”，操作系统就会把应用程序当时的状态保存起来（应用程序中断），然后系统内核执行继续执行被调用的函数。

这个过程中，发生了一些变化：一个应用从“用户状态”进入了“内核状态”。这个过程叫做“上下午切换”。
“用户状态”简称“用户态”，“内核状态”简称“内核态”。

# NIO介绍
Java的I/O操作，如果不是写长连接的应用，基本上不会涉及。而且I/O操作往往涉及到操作系统，所以深入了解的机会就更少了。这里也不做特别深入的介绍。

基本上，I/O操作有这么几种模式：
  * 阻塞I/O
  * 非阻塞I/O
  * I/O 多路复用
  * 信号驱动I/O
  * 异步I/O

JDK大概从1.4版本开始引入NIO（非阻塞I/O）,也叫做New I/O；从1.7版本开始，引入了异步I/O(AIO, Asyncrnous I/O)。

一般的，从1.7版本开始，提到NIO，基本上是包含了AIO的特性。

Kafka使用的NIO，也是充分利用了AIO特性的。

## I/O多路复用 (I/O Multiplexing)
I/O Multiplexing，俗称I/O多路复用技术，或者叫做Event Drien I/O，就是我们常说的Selector/Epoll。好处就是单个process就可以<b>同时处理</b>多个网络连接。它的基本原理就是Selector/Epoll这个function会不断轮训所负责的所有Socket连接，当某个Socket有数据到达，就通知用户进程。

## I/O缓冲区
### 概念
在I/O过程中，读取磁盘的速度相对内存读取速度要慢的多。因此为了能够加快处理数据的速度，需要将读取过的数据缓存在内存里。而这些缓存在内存里的数据就是高速缓冲区（buffer cache），下面简称为“buffer”。

具体来说，buffer（缓冲区）是一个用于存储速度不同步的设备或优先级不同的设备之间传输数据的区域。一方面，通过缓冲区，可以使进程之间的相互等待变少，从而使从速度慢的设备读入数据时，速度快的设备的操作进程不发生间断。另一方面，可以保护硬盘或减少网络传输的次数。

#### Buffer和Cache
buffer和cache是两个不同的概念：cache是高速缓存，用于CPU和内存之间的缓冲；buffer是I/O缓存，用于内存和硬盘的缓冲；简单的说，cache是加速“读”，而buffer是缓冲“写”，前者解决读的问题，保存从磁盘上读出的数据，后者是解决写的问题，保存即将要写入到磁盘上的数据。


### Buffer Cache和 Page Cache
buffer cache和page cache都是为了处理设备和内存交互时高速访问的问题。buffer cache可称为块缓冲器，page cache可称为页缓冲器。在linux不支持虚拟内存机制之前，还没有页的概念，因此缓冲区以块为单位对设备进行访问。在linux采用虚拟内存的机制来管理内存后，页是虚拟内存管理的最小单位，开始采用页缓冲的机制来缓冲内存。

Linux2.6之后内核将这两个缓存整合，页和块可以相互映射，同时，页缓存page cache面向的是虚拟内存，块I/O缓存Buffer cache是面向块设备。<b>需要强调的是，页缓存和块缓存对进程来说就是一个存储系统，进程不需要关注底层的设备的读写</b>。

buffer cache和page cache两者最大的区别是缓存的粒度。buffer cache面向的是文件系统的块。而内核的内存管理组件采用了比文件系统的块更高级别的抽象：页page，其处理的性能更高。因此和内存管理交互的缓存组件，都使用页缓存。


### Page Cache
页缓存是面向文件，面向内存的。<b>通俗来说，它位于内存和文件之间缓冲区，文件I/O操作实际上只和Page Cache交互，不直接和内存交互。</b>Page Cache可以用在所有以文件为单元的场景下，比如网络文件系统等等。Page Cache通过一系列的数据结构，比如inode, address_space, struct page，实现将一个文件映射到页的级别：

1. struct page结构标志一个物理内存页，通过page + offset就可以将此页帧定位到一个文件中的具体位置。同时struct page还有以下重要参数：
  - 标志位flags来记录该页是否是脏页，是否正在被写回等等；
  - mapping指向了地址空间address_space，表示这个页是一个页缓存中页，和一个文件的地址空间对应；
  - index记录这个页在文件中的页偏移量；

2. 文件系统的inode实际维护了这个文件所有的块block的块号，通过对文件偏移量offset取模可以很快定位到这个偏移量所在的文件系统的块号，磁盘的扇区号。同样，通过对文件偏移量offset进行取模可以计算出偏移量所在的页的偏移量。

3. page cache缓存组件抽象了地址空间address_space这个概念来作为文件系统和页缓存的中间桥梁。地址空间address_space通过指针可以方便的获取文件inode和struct page的信息，所以可以很方便地定位到一个文件的offset在各个组件中的位置，即通过：文件字节偏移量 --> 页偏移量 --> 文件系统块号 block  -->  磁盘扇区号

4. 页缓存实际上就是采用了一个基数树结构将一个文件的内容组织起来存放在物理内存struct page中。一个文件inode对应一个地址空间address_space。而一个address_space对应一个页缓存基数树。

这里是一个Page Cache形成的示意图：
![](img/create_page_cache.png)

<font color=red>*Linux系统中，每个“页”的大小是4K，后面展示的代码中有标注*</font>

### Address Space
Address_Space是Linux内核中的一个关键抽象，它被作为文件系统和页缓存的中间适配器，用来指示一个文件在页缓存中已经缓存了的物理页。因此，它是页缓存和外部设备中文件系统的桥梁。如果将文件系统可以理解成数据源，那么address_space可以说关联了内存系统和文件系统。

那么页缓存是如何通过address_space实现缓冲区功能的？我们再来看完整的文件读写流程。

### 文件读写基本流程
#### 读文件

1. 进程调用库函数向内核发起读文件请求
2. 内核通过检查进程的文件描述符定位到虚拟文件系统的已打开文件列表表项
3. 调用该文件可用的系统调用函数read()
4. read()函数通过文件表项链接到目录项模块，根据传入的文件路径，在目录项模块中检索，找到该文件的inode
5. 在inode中，通过文件内容偏移量计算出要读取的页
6. 通过inode找到文件对应的address_space
7. 在address_space中访问该文件的页缓存树，查找对应的页缓存结点
    - 如果页缓存命中，那么直接返回文件内容
    - 如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页；重新进行第6步查找页缓存
8. 文件内容读取成功。

#### 写文件
前5步和读文件一致，在address_space中查询对应页的页缓存是否存在。

6. 如果页缓存命中，直接把文件内容修改更新在页缓存的页中。<b>写文件就结束了。</b>这时候文件修改位于页缓存，并没有写回到磁盘文件中去。
7. 如果页缓存缺失，那么产生一个页缺失异常，创建一个页缓存页，同时通过inode找到文件该页的磁盘地址，读取相应的页填充该缓存页。此时缓存页命中，进行第6步。
8. 一个页缓存中的页如果被修改，那么会被标记成脏页。脏页需要写回到磁盘中的文件块。有两种方式可以把脏页写回磁盘：
    - 手动调用sync()或者fsync()系统调用把脏页写回
    - pdflush进程会定时把脏页写回到磁盘
  
同时注意，脏页不能被置换出内存，如果脏页正在被写回，那么会被设置写回标记，这时候该页就被上锁，其他写请求被阻塞直到锁释放。

# 零拷贝

## mmap是什么
mmap，它是一种内存映射文件的方法，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。

实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read,write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享。

下图是一个示意图，表达了“地址空间”与“文件”的关系：
![](img/cache-space-map-buffer-space.png)